<!DOCTYPE html>
<html lang="en">
<head>
<link rel="stylesheet" type="text/css" href="homework2.css">
</head>
<body>
<h1>me570_robot.py</h1>
<div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd"> Please merge the functions and classes from this file with the same file from the previous</span>
<span class="sd"> homework assignment</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">me570_geometry</span> <span class="k">as</span> <span class="nn">gm</span>


<span class="k">class</span> <span class="nc">TwoLink</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for creating our Two_Link Manipulator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates the two polygons necessary for the robot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">add_y_reflection</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">vertices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
            <span class="p">[</span><span class="n">vertices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vertices</span><span class="p">))])</span>

        <span class="n">vertices1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.11</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.511</span><span class="p">]])</span>
        <span class="n">vertices1</span> <span class="o">=</span> <span class="n">add_y_reflection</span><span class="p">(</span><span class="n">vertices1</span><span class="p">)</span>
        <span class="n">vertices2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">3.97</span><span class="p">,</span> <span class="mf">4.17</span><span class="p">,</span> <span class="mf">5.38</span><span class="p">,</span> <span class="mf">5.61</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">],</span>
                              <span class="p">[</span><span class="o">-</span><span class="mf">0.47</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.75</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.97</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.313</span><span class="p">]])</span>
        <span class="n">vertices2</span> <span class="o">=</span> <span class="n">add_y_reflection</span><span class="p">(</span><span class="n">vertices2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span> <span class="o">=</span> <span class="p">(</span><span class="n">gm</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">vertices1</span><span class="p">),</span> <span class="n">gm</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">vertices2</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns two polygons that represent the links in a simple 2-D two-link manipulator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span>

    <span class="k">def</span> <span class="nf">kinematic_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The function returns the coordinate of the end effector, plus the vertices of the links, all</span>
<span class="sd">    transformed according to  _1, _2.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Rotation matrices</span>
        <span class="n">w_r_beta_1</span> <span class="o">=</span> <span class="n">gm</span><span class="o">.</span><span class="n">rot2d</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">beta_1_r_beta_2</span> <span class="o">=</span> <span class="n">gm</span><span class="o">.</span><span class="n">rot2d</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">w_r_beta_2</span> <span class="o">=</span> <span class="n">w_r_beta_1</span> <span class="o">@</span> <span class="n">beta_1_r_beta_2</span>

        <span class="c1"># Translation matrix</span>
        <span class="n">beta_1_t_beta_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">w_t_beta_2</span> <span class="o">=</span> <span class="n">gm</span><span class="o">.</span><span class="n">rot2d</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">@</span> <span class="n">beta_1_t_beta_2</span>

        <span class="c1"># Transform End effector from β₂ to the world</span>
        <span class="n">vertex_effector_transf</span> <span class="o">=</span> <span class="p">(</span><span class="n">w_r_beta_2</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span> <span class="o">+</span> <span class="n">w_t_beta_2</span>

        <span class="c1"># Polygon1&#39;s coordinates are in the β₁ coordinate space, so we need to calculate ʷp_β₁</span>
        <span class="n">polygon_1_vert_transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[],</span> <span class="p">[]])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">nb_vertices</span><span class="p">):</span>
            <span class="n">vertex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">vertex_transf</span> <span class="o">=</span> <span class="p">(</span><span class="n">w_r_beta_1</span> <span class="o">@</span> <span class="n">vertex</span><span class="p">)</span>
            <span class="n">polygon_1_vert_transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                <span class="p">(</span><span class="n">polygon_1_vert_transf</span><span class="p">,</span> <span class="n">vertex_transf</span><span class="p">))</span>

        <span class="n">polygon1_transf</span> <span class="o">=</span> <span class="n">gm</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">polygon_1_vert_transf</span><span class="p">)</span>

        <span class="c1"># Polygon2&#39;s coordinates are in the β₂ coordinate space, so we need to calculate ʷp_β₂</span>
        <span class="n">polygon_2_vert_transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[],</span> <span class="p">[]])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">nb_vertices</span><span class="p">):</span>
            <span class="n">vertex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">vertex_transf</span> <span class="o">=</span> <span class="p">(</span><span class="n">w_r_beta_2</span> <span class="o">@</span> <span class="n">vertex</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_t_beta_2</span>
            <span class="n">polygon_2_vert_transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                <span class="p">(</span><span class="n">polygon_2_vert_transf</span><span class="p">,</span> <span class="n">vertex_transf</span><span class="p">))</span>

        <span class="n">polygon2_transf</span> <span class="o">=</span> <span class="n">gm</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">polygon_2_vert_transf</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">vertex_effector_transf</span><span class="p">,</span> <span class="n">polygon1_transf</span><span class="p">,</span> <span class="n">polygon2_transf</span>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function should use TwoLink.kinematic_map from the previous question together with</span>
<span class="sd">        the method Polygon.plot from Homework 1 to plot the manipulator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">[</span><span class="n">_</span><span class="p">,</span> <span class="n">polygon1_transf</span><span class="p">,</span> <span class="n">polygon2_transf</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinematic_map</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">polygon1_transf</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
        <span class="n">polygon2_transf</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_collision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each specified configuration, returns  True if  any of the links of the manipulator</span>
<span class="sd">        collides with  any of the points, and  False otherwise. Use the function</span>
<span class="sd">        Polygon.is_collision to check if each link of the manipulator is in collision.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">flag_theta</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">config</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">theta</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
            <span class="p">[</span><span class="n">_</span><span class="p">,</span> <span class="n">polygon1_transf</span><span class="p">,</span> <span class="n">polygon2_transf</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinematic_map</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>

            <span class="n">flag_points</span> <span class="o">=</span> <span class="n">polygon1_transf</span><span class="o">.</span><span class="n">is_collision</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="c1"># Must logically reverse the array because Polygon.is_collision is</span>
            <span class="c1"># returning the incorrect (opposite) answer</span>
            <span class="k">if</span> <span class="kc">True</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag_points</span><span class="p">):</span>
                <span class="n">flag_theta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="n">flag_points</span> <span class="o">=</span> <span class="n">polygon2_transf</span><span class="o">.</span><span class="n">is_collision</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="c1"># Must logically reverse the array because Polygon.is_collision is</span>
            <span class="c1"># returning the incorrect (opposite) answer</span>
            <span class="k">if</span> <span class="kc">True</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag_points</span><span class="p">):</span>
                <span class="n">flag_theta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">flag_theta</span>

    <span class="k">def</span> <span class="nf">plot_collision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function should:</span>
<span class="sd">     - Use TwoLink.is_collision for determining if each configuration is a collision or not.</span>
<span class="sd">     - Use TwoLink.plot to plot the manipulator for all configurations, using a red color when the</span>
<span class="sd">    manipulator is in collision, and green otherwise.</span>
<span class="sd">     - Plot the points specified by  points as black asterisks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">collisions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_collision</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">is_collision</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">collisions</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_collision</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;g&#39;</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">theta</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]),</span> <span class="n">color</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">theta_dot</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implement the map for the Jacobian of the position of the end effector with respect to the</span>
<span class="sd">        joint angles as derived in Question~ q:jacobian-effector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vertex_effector_dot</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">curr_theta</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">curr_theta_dot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">theta_dot</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>

            <span class="n">sin_theta_1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">curr_theta</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">cos_theta_1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">curr_theta</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="n">sin_theta_2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">curr_theta</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">cos_theta_2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">curr_theta</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">derivative_at_point</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[[</span>
                    <span class="o">-</span><span class="n">sin_theta_1</span> <span class="o">*</span> <span class="n">cos_theta_2</span> <span class="o">-</span> <span class="n">cos_theta_1</span> <span class="o">*</span> <span class="n">sin_theta_2</span> <span class="o">-</span>
                    <span class="n">sin_theta_1</span><span class="p">,</span> <span class="o">-</span><span class="n">cos_theta_1</span> <span class="o">*</span> <span class="n">sin_theta_2</span> <span class="o">-</span>
                    <span class="n">sin_theta_1</span> <span class="o">*</span> <span class="n">cos_theta_2</span> <span class="o">+</span> <span class="n">cos_theta_1</span>
                <span class="p">],</span>
                 <span class="p">[</span>
                     <span class="n">cos_theta_1</span> <span class="o">*</span> <span class="n">cos_theta_2</span> <span class="o">-</span> <span class="n">sin_theta_1</span> <span class="o">*</span> <span class="n">sin_theta_2</span> <span class="o">+</span>
                     <span class="n">cos_theta_1</span><span class="p">,</span> <span class="o">-</span><span class="n">sin_theta_1</span> <span class="o">*</span> <span class="n">sin_theta_2</span> <span class="o">+</span>
                     <span class="n">cos_theta_1</span> <span class="o">*</span> <span class="n">cos_theta_2</span> <span class="o">+</span> <span class="n">sin_theta_1</span>
                 <span class="p">]]))</span> <span class="o">@</span> <span class="n">curr_theta_dot</span>

            <span class="n">vertex_effector_dot</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">derivative_at_point</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">vertex_effector_dot</span>
</pre></div>

<h1>me570_geometry.py</h1>
<div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd"> Please merge the functions and classes from this file with the same file from the previous</span>
<span class="sd"> homework assignment</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">block_diag</span>


<span class="k">def</span> <span class="nf">numel</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Counts the number of entries in a numpy array, or returns 1 for fundamental numerical</span>
<span class="sd">    types</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">size</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;number of elements for type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">var</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">size</span>


<span class="k">def</span> <span class="nf">rot2d</span><span class="p">(</span><span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a 2-D rotation matrix from the angle  theta according to (1).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rot_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)],</span>
                          <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)]])</span>
    <span class="k">return</span> <span class="n">rot_theta</span>


<span class="k">def</span> <span class="nf">line_linspace</span><span class="p">(</span><span class="n">a_line</span><span class="p">,</span> <span class="n">b_line</span><span class="p">,</span> <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span><span class="p">,</span> <span class="n">nb_points</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a discrete number of  nb_points points along the curve</span>
<span class="sd">    (t)=( a(1)t + b(1), a(2)t + b(2))  R^2 for t ranging from  tMin to  tMax.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t_sequence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span><span class="p">,</span> <span class="n">nb_points</span><span class="p">)</span>
    <span class="n">theta_points</span> <span class="o">=</span> <span class="n">a_line</span> <span class="o">*</span> <span class="n">t_sequence</span> <span class="o">+</span> <span class="n">b_line</span>
    <span class="k">return</span> <span class="n">theta_points</span>


<span class="k">class</span> <span class="nc">Grid</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A function to store the coordinates of points on a 2-D grid and evaluate arbitrary</span>
<span class="sd">    functions on those points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xx_grid</span><span class="p">,</span> <span class="n">yy_grid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stores the input arguments in attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xx_grid</span> <span class="o">=</span> <span class="n">xx_grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yy_grid</span> <span class="o">=</span> <span class="n">yy_grid</span>

    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fun</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function evaluates the function  fun (which should be a function)</span>
<span class="sd">        on each point defined by the grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dim_domain</span> <span class="o">=</span> <span class="p">[</span><span class="n">numel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xx_grid</span><span class="p">),</span> <span class="n">numel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">yy_grid</span><span class="p">)]</span>
        <span class="n">dim_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">numel</span><span class="p">(</span><span class="n">fun</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])))]</span>
        <span class="n">fun_eval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">dim_domain</span> <span class="o">+</span> <span class="n">dim_range</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx_x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim_domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">idx_y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim_domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">x_eval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="bp">self</span><span class="o">.</span><span class="n">xx_grid</span><span class="p">[</span><span class="n">idx_x</span><span class="p">]],</span>
                                   <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">yy_grid</span><span class="p">[</span><span class="n">idx_y</span><span class="p">]]])</span>
                <span class="n">fun_eval</span><span class="p">[</span><span class="n">idx_x</span><span class="p">,</span> <span class="n">idx_y</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">fun</span><span class="p">(</span><span class="n">x_eval</span><span class="p">),</span>
                                                       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

        <span class="c1"># If the last dimension is a singleton, remove it</span>
        <span class="k">if</span> <span class="n">dim_range</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">fun_eval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">fun_eval</span><span class="p">,</span> <span class="n">dim_domain</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fun_eval</span>

    <span class="k">def</span> <span class="nf">mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shorhand for calling meshgrid on the points of the grid</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xx_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yy_grid</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Torus</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class that holds functions to compute the embedding and display a torus and curves on it.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">phi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implements equation (eq:chartTorus).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_torus</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">curr_theta</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">phi_circle</span> <span class="o">=</span> <span class="n">rot2d</span><span class="p">(</span><span class="n">curr_theta</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">phi_circle_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
            <span class="n">phi_circle_trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">rot_xy_around_z</span> <span class="o">=</span> <span class="n">block_diag</span><span class="p">(</span><span class="n">rot2d</span><span class="p">(</span><span class="n">curr_theta</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">x_torus</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rot_xy_around_z</span> <span class="o">@</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">phi_circle_mat</span> <span class="o">@</span> <span class="n">phi_circle</span><span class="p">)</span> <span class="o">+</span> <span class="n">phi_circle_trans</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">x_torus</span>

    <span class="k">def</span> <span class="nf">plot_charts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each one of the chart domains U_i from the previous question:</span>
<span class="sd">        - Fill a  grid structure with fields  xx_grid and  yy_grid that define a grid of regular</span>
<span class="sd">          point in U_i. Use nb_grid=33.</span>
<span class="sd">        - Call the function Grid.eval with argument Torus.phi.</span>
<span class="sd">        - Plots the surface described by the previous step using the the Matplotlib function</span>
<span class="sd">        ax.plot_surface (where  ax represents the axes of the current figure) in a separate figure.</span>
<span class="sd">        Plot a final additional figure showing all the charts at the same time.   To better show</span>
<span class="sd">        the overlap between the charts, you can use different colors each one of them,</span>
<span class="sd">        and making them slightly transparent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">theta</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">nb_grid</span> <span class="o">=</span> <span class="mi">33</span>

        <span class="n">u_subspace_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="mf">0.1</span><span class="p">,</span>
                         <span class="n">nb_grid</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">nb_grid</span><span class="p">)))</span>

        <span class="n">u_subspace_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span>
                         <span class="n">nb_grid</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="mf">0.1</span><span class="p">,</span>
                                               <span class="n">nb_grid</span><span class="p">)))</span>

        <span class="n">u_subspace_3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="mf">0.1</span><span class="p">,</span>
                         <span class="n">nb_grid</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">nb_grid</span><span class="p">)))</span>

        <span class="n">u_subspace_4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span>
                         <span class="n">nb_grid</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span>
                                               <span class="n">nb_grid</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">phi_push_curve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a_line</span><span class="p">,</span> <span class="n">b_line</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function evaluates the curve x(t)= phi_torus ( phi(t) )  R^3 at  nb_points=31 points</span>
<span class="sd">        generated along the curve phi(t) using line_linspaceLine.linspace with  tMin=0 and  tMax=1,</span>
<span class="sd">        and a, b as given in the input arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nb_points</span> <span class="o">=</span> <span class="mi">31</span>
        <span class="n">theta_sequence</span> <span class="o">=</span> <span class="n">line_linspace</span><span class="p">(</span><span class="n">a_line</span><span class="p">,</span> <span class="n">b_line</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nb_points</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_points</span><span class="p">):</span>
            <span class="n">curr_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">theta_sequence</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">x_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">curr_theta</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">x_points</span>

    <span class="k">def</span> <span class="nf">plot_charts_curves</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The function should iterate over the following four curves:</span>
<span class="sd">        - 3/4*pi0</span>
<span class="sd">        - 3/4*pi3/4*pi</span>
<span class="sd">        - -3/4*pi3/4*pi</span>
<span class="sd">        - 03/4*pi  and  b=np.array([[-1],[-1]]).</span>
<span class="sd">        The function should show an overlay containing:</span>
<span class="sd">        - The output of Torus.plotCharts;</span>
<span class="sd">        - The output of the functions torus_pushCurveTorus.pushCurve for each one of the curves.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a_lines</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">3</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">]]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">3</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">]]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">]])</span>
        <span class="p">]</span>

        <span class="n">b_line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

        <span class="k">for</span> <span class="n">a_line</span> <span class="ow">in</span> <span class="n">a_lines</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phi_push_curve</span><span class="p">(</span><span class="n">a_line</span><span class="p">,</span> <span class="n">b_line</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Polygon</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Class for plotting, drawing, checking visibility and collision with polygons. &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the input coordinates to the internal attribute  vertices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nb_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Number of vertices &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">flip</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reverse the order of the vertices (i.e., transform the polygon from filled in</span>
<span class="sd">        to hollow and viceversa).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">style</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the polygon using Matplotlib.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">style</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">style</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span>

        <span class="n">directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices_loop</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span>
                   <span class="n">directions</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span>
                   <span class="n">directions</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span>
                   <span class="n">color</span><span class="o">=</span><span class="n">style</span><span class="p">,</span>
                   <span class="n">angles</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span>
                   <span class="n">scale_units</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span>
                   <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vertices_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns self.vertices with the first vertex repeated at the end</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>

    <span class="k">def</span> <span class="nf">is_filled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks the ordering of the vertices, and returns whether the polygon is filled in or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Iteratres over the columns of the 2D Matrix to perform the calculation</span>
        <span class="c1"># sum((x_2 - x_1) * (y_2 + y_1))</span>
        <span class="c1"># If the sum is negative, then the polygon is oriented counter-clockwise,</span>
        <span class="c1"># clockwise otherwise.</span>

        <span class="n">num_cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">running_sum</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_cols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">x_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">y_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

            <span class="c1"># modulus is for the last element to be compared with the first to close the shape</span>
            <span class="n">running_sum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x_vals</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">num_cols</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_vals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> \
                <span class="p">(</span><span class="n">y_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y_vals</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">num_cols</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">running_sum</span> <span class="o">&lt;</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">is_self_occluded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx_vertex</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the corner of a polygon, checks whether a given point is self-occluded or not by</span>
<span class="sd">        that polygon (i.e., if it is ``inside&#39;&#39; the corner&#39;s cone or not). Points on boundary</span>
<span class="sd">        (i.e., on one of the sides of the corner) are not considered self-occluded. Note that</span>
<span class="sd">        to check self-occlusion, we just need a vertex index  idx_vertex. From this, one can</span>
<span class="sd">        obtain the corresponding  vertex, and the  vertex_prev and  vertex_next that precede</span>
<span class="sd">        and follow that vertex in the polygon.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vertex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span> <span class="p">[</span><span class="n">idx_vertex</span><span class="p">]]</span>
        <span class="n">vertex_next</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span> <span class="p">[(</span><span class="n">idx_vertex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_vertices</span><span class="p">]]</span>
        <span class="n">vertex_prev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span> <span class="p">[(</span><span class="n">idx_vertex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_vertices</span><span class="p">]]</span>

        <span class="c1"># The point is occluded if, measuring angles using p-vertex as the &quot;zero angle&quot;,</span>
        <span class="c1"># the angle for vertex_prev is smaller than the one for vertex_next</span>
        <span class="c1"># Using the &#39;unsigned&#39; angles means that we do not have to worry separately</span>
        <span class="c1"># about negative angles</span>
        <span class="n">angle_p_prev</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">vertex_prev</span><span class="p">,</span> <span class="s1">&#39;unsigned&#39;</span><span class="p">)</span>
        <span class="n">angle_p_next</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">vertex_next</span><span class="p">,</span> <span class="s1">&#39;unsigned&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">angle_p_prev</span> <span class="o">&lt;</span> <span class="n">angle_p_next</span>

    <span class="k">def</span> <span class="nf">is_visible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx_vertex</span><span class="p">,</span> <span class="n">test_points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether a point p is visible from a vertex v of a polygon. In order to be visible,</span>
<span class="sd">        two conditions need to be satisfied: enumerate  point p should not be self-occluded with</span>
<span class="sd">        respect to the vertex v (see Polygon.is_self_occluded). The segment p--v should not collide</span>
<span class="sd">        with any of the edges of the polygon (see Edge.is_collision).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nb_test_points</span> <span class="o">=</span> <span class="n">test_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nb_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Initial default: all flags are True</span>
        <span class="n">flag_points</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="n">nb_test_points</span>
        <span class="n">vertex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span> <span class="p">[</span><span class="n">idx_vertex</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">idx_point</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_test_points</span><span class="p">):</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">test_points</span><span class="p">[:,</span> <span class="p">[</span><span class="n">idx_point</span><span class="p">]]</span>

            <span class="c1"># If it is self occluded, bail out</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_self_occluded</span><span class="p">(</span><span class="n">idx_vertex</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
                <span class="n">flag_points</span><span class="p">[</span><span class="n">idx_point</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Build the vertex-point edge (it is the same for all other edges)</span>
                <span class="n">edge_vertex_point</span> <span class="o">=</span> <span class="n">Edge</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">point</span><span class="p">,</span> <span class="n">vertex</span><span class="p">]))</span>
                <span class="c1"># Then iterate over all edges in the polygon</span>
                <span class="k">for</span> <span class="n">idx_vertex_collision</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_vertices</span><span class="p">):</span>
                    <span class="n">edge_vertex_vertex</span> <span class="o">=</span> <span class="n">Edge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span> <span class="p">[</span>
                        <span class="n">idx_vertex_collision</span><span class="p">,</span>
                        <span class="p">(</span><span class="n">idx_vertex_collision</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">nb_vertices</span>
                    <span class="p">]])</span>
                    <span class="c1"># The final result is the and of all the checks with individual edges</span>
                    <span class="n">flag_points</span><span class="p">[</span>
                        <span class="n">idx_point</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="ow">not</span> <span class="n">edge_vertex_point</span><span class="o">.</span><span class="n">is_collision</span><span class="p">(</span>
                            <span class="n">edge_vertex_vertex</span><span class="p">)</span>

                    <span class="c1"># Early bail out after one collision</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">flag_points</span><span class="p">[</span><span class="n">idx_point</span><span class="p">]:</span>
                        <span class="k">break</span>

        <span class="k">return</span> <span class="n">flag_points</span>

    <span class="k">def</span> <span class="nf">is_collision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test_points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether the a point is in collsion with a polygon (that is, inside for a filled in</span>
<span class="sd">        polygon, and outside for a hollow polygon). In the context of this homework, this function</span>
<span class="sd">        is best implemented using Polygon.is_visible.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">flag_points</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">test_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># We iterate over the polygon vertices, and process all the test points in parallel</span>
        <span class="k">for</span> <span class="n">idx_vertex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_vertices</span><span class="p">):</span>
            <span class="n">flag_points_vertex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_visible</span><span class="p">(</span><span class="n">idx_vertex</span><span class="p">,</span> <span class="n">test_points</span><span class="p">)</span>
            <span class="c1"># Accumulate the new flags with the previous ones</span>
            <span class="n">flag_points</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">flag_prev</span> <span class="ow">or</span> <span class="n">flag_new</span>
                <span class="k">for</span> <span class="n">flag_prev</span><span class="p">,</span> <span class="n">flag_new</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">flag_points</span><span class="p">,</span> <span class="n">flag_points_vertex</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="k">return</span> <span class="n">flag_points</span>


<span class="k">class</span> <span class="nc">Edge</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Class for storing edges and checking collisions among them. &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the input coordinates to the internal attribute  vertices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">direction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Difference between tip and base &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">base</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Coordinates of the first vertex&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

    <span class="k">def</span> <span class="nf">is_collision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns  True if the two edges intersect.  Note: if the two edges overlap but are colinear,</span>
<span class="sd">        or they overlap only at a single endpoint, they are not considered as intersecting (i.e.,</span>
<span class="sd">        in these cases the function returns  False). If one of the two edges has zero length, the</span>
<span class="sd">        function should always return the result that edges are non-intersecting.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Write the lines from the two edges as x_i(t_i)=edge_base+edge.direction*t_i</span>
        <span class="c1"># Then finds the parameters for the intersection by solving the linear system obtained from</span>
        <span class="c1"># x_1(t_1)=x_2(t_2)</span>

        <span class="c1"># Tolerance for cases involving parallel lines and endpoints</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-6</span>

        <span class="c1"># The matrix of the linear system</span>
        <span class="n">a_directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">,</span> <span class="o">-</span><span class="n">edge</span><span class="o">.</span><span class="n">direction</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">a_directions</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="c1"># Lines are practically parallel</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># The vector of the linear system</span>
        <span class="n">b_bases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">edge</span><span class="o">.</span><span class="n">base</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">])</span>

        <span class="c1"># Solve the linear system</span>
        <span class="n">t_param</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">a_directions</span><span class="p">,</span> <span class="n">b_bases</span><span class="p">)</span>
        <span class="n">t_self</span> <span class="o">=</span> <span class="n">t_param</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">t_other</span> <span class="o">=</span> <span class="n">t_param</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Check that collision point is strictly between endpoints of each edge</span>
        <span class="n">flag_collision</span> <span class="o">=</span> <span class="n">tol</span> <span class="o">&lt;</span> <span class="n">t_self</span> <span class="o">&lt;</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">tol</span> <span class="ow">and</span> <span class="n">tol</span> <span class="o">&lt;</span> <span class="n">t_other</span> <span class="o">&lt;</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">tol</span>

        <span class="k">return</span> <span class="n">flag_collision</span>


<span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="n">vertex0</span><span class="p">,</span> <span class="n">vertex1</span><span class="p">,</span> <span class="n">vertex2</span><span class="p">,</span> <span class="n">angle_type</span><span class="o">=</span><span class="s1">&#39;signed&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the angle between two edges  vertex0-vertex1 and  vertex0-vertex2 having an endpoint in</span>
<span class="sd">    common. The angle is computed by starting from the edge  vertex0-- vertex1, and then</span>
<span class="sd">    ``walking&#39;&#39; in a counterclockwise manner until the edge  vertex0-vertex2 is found.</span>
<span class="sd">    The angle is computed by starting from the vertex0-vertex1 edge, and then “walking” in a</span>
<span class="sd">    counterclockwise manner until the is found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># tolerance to check for coincident points</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">2.22e-16</span>

    <span class="c1"># compute vectors corresponding to the two edges, and normalize</span>
    <span class="n">vec1</span> <span class="o">=</span> <span class="n">vertex1</span> <span class="o">-</span> <span class="n">vertex0</span>
    <span class="n">vec2</span> <span class="o">=</span> <span class="n">vertex2</span> <span class="o">-</span> <span class="n">vertex0</span>

    <span class="n">norm_vec1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec1</span><span class="p">)</span>
    <span class="n">norm_vec2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">norm_vec1</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">or</span> <span class="n">norm_vec2</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
        <span class="c1"># vertex1 or vertex2 coincides with vertex0, abort</span>
        <span class="n">edge_angle</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">edge_angle</span>

    <span class="n">vec1</span> <span class="o">=</span> <span class="n">vec1</span> <span class="o">/</span> <span class="n">norm_vec1</span>
    <span class="n">vec2</span> <span class="o">=</span> <span class="n">vec2</span> <span class="o">/</span> <span class="n">norm_vec2</span>

    <span class="c1"># Transform vec1 and vec2 into flat 3-D vectors,</span>
    <span class="c1"># so that they can be used with np.inner and np.cross</span>
    <span class="n">vec1flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">vec1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">vec2flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">vec2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="n">c_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">vec1flat</span><span class="p">,</span> <span class="n">vec2flat</span><span class="p">)</span>
    <span class="n">s_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">vec1flat</span><span class="p">,</span> <span class="n">vec2flat</span><span class="p">))</span>

    <span class="n">edge_angle</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">s_angle</span><span class="p">,</span> <span class="n">c_angle</span><span class="p">)</span>

    <span class="n">angle_type</span> <span class="o">=</span> <span class="n">angle_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">angle_type</span> <span class="o">==</span> <span class="s1">&#39;signed&#39;</span><span class="p">:</span>
        <span class="c1"># nothing to do</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">angle_type</span> <span class="o">==</span> <span class="s1">&#39;unsigned&#39;</span><span class="p">:</span>
        <span class="n">edge_angle</span> <span class="o">=</span> <span class="p">(</span><span class="n">edge_angle</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid argument angle_type&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">edge_angle</span>
</pre></div>

<h1>me570_hw2.py</h1>
<div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Main file for ME570 HW2</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">io</span> <span class="k">as</span> <span class="n">scio</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">me570_geometry</span>
<span class="kn">import</span> <span class="nn">me570_robot</span>


<span class="k">def</span> <span class="nf">twolink_plot_collision_test</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function generates 30 random configurations, loads the  points variable from the file</span>
<span class="sd">!70!DarkSeaGreen2 twolink_testData.mat (provided with the homework), and then display the results</span>
<span class="sd">using  twolink_plotCollision to plot the manipulator in red if it is in collision, and green</span>
<span class="sd">otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nb_configurations</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="n">two_link</span> <span class="o">=</span> <span class="n">me570_robot</span><span class="o">.</span><span class="n">TwoLink</span><span class="p">()</span>
    <span class="n">theta_random</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">nb_configurations</span><span class="p">)</span>
    <span class="n">test_data</span> <span class="o">=</span> <span class="n">scio</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="s1">&#39;twolink_testData.mat&#39;</span><span class="p">)</span>
    <span class="n">obstacle_points</span> <span class="o">=</span> <span class="n">test_data</span><span class="p">[</span><span class="s1">&#39;obstaclePoints&#39;</span><span class="p">]</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">obstacle_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">obstacle_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="s1">&#39;r*&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i_theta</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_configurations</span><span class="p">):</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">theta_random</span><span class="p">[:,</span> <span class="n">i_theta</span><span class="p">:</span><span class="n">i_theta</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">two_link</span><span class="o">.</span><span class="n">plot_collision</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">obstacle_points</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">grid_eval_example</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Example of the use of Grid.mesh and Grid.eval functions&quot;&quot;&quot;</span>
    <span class="n">fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">example_grid</span> <span class="o">=</span> <span class="n">me570_geometry</span><span class="o">.</span><span class="n">Grid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">fun_eval</span> <span class="o">=</span> <span class="n">example_grid</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">fun</span><span class="p">)</span>
    <span class="p">[</span><span class="n">xx_grid</span><span class="p">,</span> <span class="n">yy_grid</span><span class="p">]</span> <span class="o">=</span> <span class="n">example_grid</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
    <span class="n">axis</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">xx_grid</span><span class="p">,</span> <span class="n">yy_grid</span><span class="p">,</span> <span class="n">fun_eval</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">torus_twolink_plot_jacobian</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For each one of the curves used in Question~ q:torusDrawChartsCurves, do the following:</span>
<span class="sd"> - Use Line.linspace to compute the array  thetaPoints for the curve;</span>
<span class="sd"> - For each one of the configurations given by the columns of  thetaPoints:</span>
<span class="sd"> - Use Twolink.plot to plot the two-link manipulator.</span>
<span class="sd"> - Use Twolink.jacobian to compute the velocity of the end effector, and then use quiver to draw</span>
<span class="sd">that velocity as an arrow starting from the end effector&#39;s position.   The function should produce a</span>
<span class="sd">total of four windows (or, alternatively, a single window with four subplots), each window (or</span>
<span class="sd">subplot) showing all the configurations of the manipulator superimposed on each other. You can use</span>
<span class="sd">matplotlib.pyplot.ion and insert a time.sleep command in the loop for drawing the manipulator, in</span>
<span class="sd">order to obtain a ``movie-like&#39;&#39; presentation of the motion.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">1</span>
</pre></div>

</body>
</html>