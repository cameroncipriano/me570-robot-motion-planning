<!DOCTYPE html>
<html lang="en">
<head>
<link rel="stylesheet" type="text/css" href="homework3.css">
</head>
<body>
<h1>me570_geometry.py</h1>
<div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd"> Please merge the functions and classes from this file with the same file from the previous</span>
<span class="sd"> homework assignment</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span><span class="p">,</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>


<span class="k">def</span> <span class="nf">numel</span><span class="p">(</span><span class="n">var</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Counts the number of entries in a numpy array, or returns 1 for fundamental numerical</span>
<span class="sd">    types</span>

<span class="sd">    [This function is the same as the one from HW2]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">size</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># breakpoint()</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;number of elements for type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">var</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">size</span>


<span class="k">def</span> <span class="nf">rot2d</span><span class="p">(</span><span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a 2-D rotation matrix from the angle  theta according to (1).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rot_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)],</span>
                          <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)]])</span>
    <span class="k">return</span> <span class="n">rot_theta</span>


<span class="k">def</span> <span class="nf">line_linspace</span><span class="p">(</span><span class="n">a_line</span><span class="p">,</span> <span class="n">b_line</span><span class="p">,</span> <span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span><span class="p">,</span> <span class="n">nb_points</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a discrete number of  nb_points points along the curve</span>
<span class="sd">    (t)=( a(1)t + b(1), a(2)t + b(2))  R^2 for t ranging from  tMin to  tMax.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t_sequence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t_min</span><span class="p">,</span> <span class="n">t_max</span><span class="p">,</span> <span class="n">nb_points</span><span class="p">)</span>
    <span class="n">theta_points</span> <span class="o">=</span> <span class="n">a_line</span> <span class="o">*</span> <span class="n">t_sequence</span> <span class="o">+</span> <span class="n">b_line</span>
    <span class="k">return</span> <span class="n">theta_points</span>


<span class="k">class</span> <span class="nc">Grid</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A function to store the coordinates of points on a 2-D grid and evaluate arbitrary</span>
<span class="sd">    functions on those points.</span>

<span class="sd">    [This class is the same as the one from HW2]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xx_grid</span><span class="p">,</span> <span class="n">yy_grid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stores the input arguments in attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xx_grid</span> <span class="o">=</span> <span class="n">xx_grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yy_grid</span> <span class="o">=</span> <span class="n">yy_grid</span>

    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fun</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function evaluates the function  fun (which should be a function)</span>
<span class="sd">        on each point defined by the grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dim_domain</span> <span class="o">=</span> <span class="p">[</span><span class="n">numel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xx_grid</span><span class="p">),</span> <span class="n">numel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">yy_grid</span><span class="p">)]</span>
        <span class="n">dim_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">numel</span><span class="p">(</span><span class="n">fun</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])))]</span>
        <span class="n">fun_eval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">dim_domain</span> <span class="o">+</span> <span class="n">dim_range</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx_x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim_domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">idx_y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim_domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">x_eval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="bp">self</span><span class="o">.</span><span class="n">xx_grid</span><span class="p">[</span><span class="n">idx_x</span><span class="p">]],</span>
                                   <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">yy_grid</span><span class="p">[</span><span class="n">idx_y</span><span class="p">]]])</span>
                <span class="n">fun_eval</span><span class="p">[</span><span class="n">idx_x</span><span class="p">,</span> <span class="n">idx_y</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">fun</span><span class="p">(</span><span class="n">x_eval</span><span class="p">),</span>
                                                       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dim_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

        <span class="c1"># If the last dimension is a singleton, remove it</span>
        <span class="k">if</span> <span class="n">dim_range</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">fun_eval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">fun_eval</span><span class="p">,</span> <span class="n">dim_domain</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fun_eval</span>

    <span class="k">def</span> <span class="nf">mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shorhand for calling meshgrid on the points of the grid</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xx_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yy_grid</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">clip</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If val is a scalar, threshold its value; if it is a vector, normalized it</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">val_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">val_norm</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">/=</span> <span class="n">val_norm</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Numeric format not recognized&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">val</span>


<span class="k">def</span> <span class="nf">field_plot_threshold</span><span class="p">(</span><span class="n">f_handle</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">nb_grid</span><span class="o">=</span><span class="mi">61</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The function evaluates the function  f_handle on points placed on a regular grid.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">xx_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">11</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="n">nb_grid</span><span class="p">)</span>
    <span class="n">yy_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">11</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="n">nb_grid</span><span class="p">)</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">(</span><span class="n">xx_grid</span><span class="p">,</span> <span class="n">yy_grid</span><span class="p">)</span>

    <span class="n">f_handle_clip</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">val</span><span class="p">:</span> <span class="n">clip</span><span class="p">(</span><span class="n">f_handle</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="n">f_eval</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">f_handle_clip</span><span class="p">)</span>

    <span class="p">[</span><span class="n">xx_mesh</span><span class="p">,</span> <span class="n">yy_mesh</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">mesh</span><span class="p">()</span>
    <span class="n">f_dim</span> <span class="o">=</span> <span class="n">numel</span><span class="p">(</span><span class="n">f_handle_clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))))</span>
    <span class="k">if</span> <span class="n">f_dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># scalar field</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>

        <span class="n">axis</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">xx_mesh</span><span class="p">,</span>
                          <span class="n">yy_mesh</span><span class="p">,</span>
                          <span class="n">f_eval</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span>
                          <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">gnuplot2</span><span class="p">)</span>
        <span class="n">axis</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="mi">90</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">f_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># vector field</span>
        <span class="c1"># grid.eval gives the result transposed with respect to what meshgrid expects</span>
        <span class="n">f_eval</span> <span class="o">=</span> <span class="n">f_eval</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="c1"># vector field</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="n">xx_mesh</span><span class="p">,</span>
                   <span class="n">yy_mesh</span><span class="p">,</span>
                   <span class="n">f_eval</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">],</span>
                   <span class="n">f_eval</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">],</span>
                   <span class="n">angles</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span>
                   <span class="n">scale_units</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;Field plotting for dimension greater than two not implemented&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Sphere</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Class for plotting and computing distances to spheres (circles, in 2-D). &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">distance_influence</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the parameters describing the sphere as internal attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance_influence</span> <span class="o">=</span> <span class="n">distance_influence</span>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function draws the sphere (i.e., a circle) of the given radius, and the specified color,</span>
<span class="sd">    and then draws another circle in gray with radius equal to the distance of influence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get current axes</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

        <span class="c1"># Added these in to make circles look like circles and actually get circles to display</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>

        <span class="c1"># Add circle as a patch</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Circle is filled in</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;facecolor&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)}</span>
            <span class="n">radius_influence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_influence</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Circle is hollow</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fill&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
            <span class="n">radius_influence</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_influence</span>

        <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">(</span><span class="n">center</span><span class="p">,</span>
                       <span class="n">radius</span><span class="o">=</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">),</span>
                       <span class="n">edgecolor</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="n">axes</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">Circle</span><span class="p">(</span><span class="n">center</span><span class="p">,</span>
                       <span class="n">radius</span><span class="o">=</span><span class="n">radius_influence</span><span class="p">,</span>
                       <span class="n">edgecolor</span><span class="o">=</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">),</span>
                       <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the signed distance between points and the sphere, while taking into account whether</span>
<span class="sd">    the sphere is hollow or filled in.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d_points_sphere</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">points</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">d_points_sphere</span>
        <span class="k">return</span> <span class="n">d_points_sphere</span>

    <span class="k">def</span> <span class="nf">distance_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the gradient of the signed distance between points and the sphere, consistently with</span>
<span class="sd">    the definition of Sphere.distance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">points</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">denom</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">grad_d_points_sphere</span> <span class="o">=</span> <span class="p">(</span><span class="n">points</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
            <span class="n">points</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">grad_d_points_sphere</span>
        <span class="k">return</span> <span class="n">grad_d_points_sphere</span>

    <span class="k">def</span> <span class="nf">is_collision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines whether a point collides with the sphere using its distance</span>
<span class="sd">        as the metric for collision</span>

<span class="sd">        distance &lt;= 0 means collision in both solid and hollow</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">point</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">points</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">flag_points</span>

    <span class="k">def</span> <span class="nf">flip</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Turns the Sphere from Solid -&gt; Hollow and vice versa</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">radius</span>


<span class="k">class</span> <span class="nc">Polygon</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Class for plotting, drawing, checking visibility and collision with polygons. &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the input coordinates to the internal attribute  vertices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nb_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Number of vertices &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">flip</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reverse the order of the vertices (i.e., transform the polygon from filled in</span>
<span class="sd">        to hollow and viceversa).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">style</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the polygon using Matplotlib.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">style</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">style</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span>

        <span class="n">directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices_loop</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span>
                   <span class="n">directions</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span>
                   <span class="n">directions</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span>
                   <span class="n">color</span><span class="o">=</span><span class="n">style</span><span class="p">,</span>
                   <span class="n">angles</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span>
                   <span class="n">scale_units</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span>
                   <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vertices_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns self.vertices with the first vertex repeated at the end</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>

    <span class="k">def</span> <span class="nf">is_filled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks the ordering of the vertices, and returns whether the polygon is filled in or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Iteratres over the columns of the 2D Matrix to perform the calculation</span>
        <span class="c1"># sum((x_2 - x_1) * (y_2 + y_1))</span>
        <span class="c1"># If the sum is negative, then the polygon is oriented counter-clockwise,</span>
        <span class="c1"># clockwise otherwise.</span>

        <span class="n">num_cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">running_sum</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_cols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">x_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">y_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

            <span class="c1"># modulus is for the last element to be compared with the first to close the shape</span>
            <span class="n">running_sum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x_vals</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">num_cols</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_vals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> \
                <span class="p">(</span><span class="n">y_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y_vals</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">num_cols</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">running_sum</span> <span class="o">&lt;</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">is_self_occluded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx_vertex</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the corner of a polygon, checks whether a given point is self-occluded or not by</span>
<span class="sd">        that polygon (i.e., if it is ``inside&#39;&#39; the corner&#39;s cone or not). Points on boundary</span>
<span class="sd">        (i.e., on one of the sides of the corner) are not considered self-occluded. Note that</span>
<span class="sd">        to check self-occlusion, we just need a vertex index  idx_vertex. From this, one can</span>
<span class="sd">        obtain the corresponding  vertex, and the  vertex_prev and  vertex_next that precede</span>
<span class="sd">        and follow that vertex in the polygon.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vertex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span> <span class="p">[</span><span class="n">idx_vertex</span><span class="p">]]</span>
        <span class="n">vertex_next</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span> <span class="p">[(</span><span class="n">idx_vertex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_vertices</span><span class="p">]]</span>
        <span class="n">vertex_prev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span> <span class="p">[(</span><span class="n">idx_vertex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_vertices</span><span class="p">]]</span>

        <span class="c1"># The point is occluded if, measuring angles using p-vertex as the &quot;zero angle&quot;,</span>
        <span class="c1"># the angle for vertex_prev is smaller than the one for vertex_next</span>
        <span class="c1"># Using the &#39;unsigned&#39; angles means that we do not have to worry separately</span>
        <span class="c1"># about negative angles</span>
        <span class="n">angle_p_prev</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">vertex_prev</span><span class="p">,</span> <span class="s1">&#39;unsigned&#39;</span><span class="p">)</span>
        <span class="n">angle_p_next</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">vertex_next</span><span class="p">,</span> <span class="s1">&#39;unsigned&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">angle_p_prev</span> <span class="o">&lt;</span> <span class="n">angle_p_next</span>

    <span class="k">def</span> <span class="nf">is_visible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx_vertex</span><span class="p">,</span> <span class="n">test_points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether a point p is visible from a vertex v of a polygon. In order to be visible,</span>
<span class="sd">        two conditions need to be satisfied: enumerate  point p should not be self-occluded with</span>
<span class="sd">        respect to the vertex v (see Polygon.is_self_occluded). The segment p--v should not collide</span>
<span class="sd">        with any of the edges of the polygon (see Edge.is_collision).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nb_test_points</span> <span class="o">=</span> <span class="n">test_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nb_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Initial default: all flags are True</span>
        <span class="n">flag_points</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="n">nb_test_points</span>
        <span class="n">vertex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span> <span class="p">[</span><span class="n">idx_vertex</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">idx_point</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_test_points</span><span class="p">):</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">test_points</span><span class="p">[:,</span> <span class="p">[</span><span class="n">idx_point</span><span class="p">]]</span>

            <span class="c1"># If it is self occluded, bail out</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_self_occluded</span><span class="p">(</span><span class="n">idx_vertex</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
                <span class="n">flag_points</span><span class="p">[</span><span class="n">idx_point</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Build the vertex-point edge (it is the same for all other edges)</span>
                <span class="n">edge_vertex_point</span> <span class="o">=</span> <span class="n">Edge</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">point</span><span class="p">,</span> <span class="n">vertex</span><span class="p">]))</span>
                <span class="c1"># Then iterate over all edges in the polygon</span>
                <span class="k">for</span> <span class="n">idx_vertex_collision</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_vertices</span><span class="p">):</span>
                    <span class="n">edge_vertex_vertex</span> <span class="o">=</span> <span class="n">Edge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span> <span class="p">[</span>
                        <span class="n">idx_vertex_collision</span><span class="p">,</span>
                        <span class="p">(</span><span class="n">idx_vertex_collision</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">nb_vertices</span>
                    <span class="p">]])</span>
                    <span class="c1"># The final result is the and of all the checks with individual edges</span>
                    <span class="n">flag_points</span><span class="p">[</span>
                        <span class="n">idx_point</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="ow">not</span> <span class="n">edge_vertex_point</span><span class="o">.</span><span class="n">is_collision</span><span class="p">(</span>
                            <span class="n">edge_vertex_vertex</span><span class="p">)</span>

                    <span class="c1"># Early bail out after one collision</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">flag_points</span><span class="p">[</span><span class="n">idx_point</span><span class="p">]:</span>
                        <span class="k">break</span>

        <span class="k">return</span> <span class="n">flag_points</span>

    <span class="k">def</span> <span class="nf">is_collision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">test_points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether the a point is in collsion with a polygon (that is, inside for a filled in</span>
<span class="sd">        polygon, and outside for a hollow polygon). In the context of this homework, this function</span>
<span class="sd">        is best implemented using Polygon.is_visible.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">flag_points</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">test_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># We iterate over the polygon vertices, and process all the test points in parallel</span>
        <span class="k">for</span> <span class="n">idx_vertex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_vertices</span><span class="p">):</span>
            <span class="n">flag_points_vertex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_visible</span><span class="p">(</span><span class="n">idx_vertex</span><span class="p">,</span> <span class="n">test_points</span><span class="p">)</span>
            <span class="c1"># Accumulate the new flags with the previous ones</span>
            <span class="n">flag_points</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">flag_prev</span> <span class="ow">or</span> <span class="n">flag_new</span>
                <span class="k">for</span> <span class="n">flag_prev</span><span class="p">,</span> <span class="n">flag_new</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">flag_points</span><span class="p">,</span> <span class="n">flag_points_vertex</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="k">return</span> <span class="n">flag_points</span>


<span class="k">class</span> <span class="nc">Edge</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Class for storing edges and checking collisions among them. &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the input coordinates to the internal attribute  vertices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">direction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Difference between tip and base &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">base</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Coordinates of the first vertex&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

    <span class="k">def</span> <span class="nf">is_collision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns  True if the two edges intersect.  Note: if the two edges overlap but are colinear,</span>
<span class="sd">        or they overlap only at a single endpoint, they are not considered as intersecting (i.e.,</span>
<span class="sd">        in these cases the function returns  False). If one of the two edges has zero length, the</span>
<span class="sd">        function should always return the result that edges are non-intersecting.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Write the lines from the two edges as x_i(t_i)=edge_base+edge.direction*t_i</span>
        <span class="c1"># Then finds the parameters for the intersection by solving the linear system obtained from</span>
        <span class="c1"># x_1(t_1)=x_2(t_2)</span>

        <span class="c1"># Tolerance for cases involving parallel lines and endpoints</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-6</span>

        <span class="c1"># The matrix of the linear system</span>
        <span class="n">a_directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="p">,</span> <span class="o">-</span><span class="n">edge</span><span class="o">.</span><span class="n">direction</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">a_directions</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="c1"># Lines are practically parallel</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># The vector of the linear system</span>
        <span class="n">b_bases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">edge</span><span class="o">.</span><span class="n">base</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">])</span>

        <span class="c1"># Solve the linear system</span>
        <span class="n">t_param</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">a_directions</span><span class="p">,</span> <span class="n">b_bases</span><span class="p">)</span>
        <span class="n">t_self</span> <span class="o">=</span> <span class="n">t_param</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">t_other</span> <span class="o">=</span> <span class="n">t_param</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Check that collision point is strictly between endpoints of each edge</span>
        <span class="n">flag_collision</span> <span class="o">=</span> <span class="n">tol</span> <span class="o">&lt;</span> <span class="n">t_self</span> <span class="o">&lt;</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">tol</span> <span class="ow">and</span> <span class="n">tol</span> <span class="o">&lt;</span> <span class="n">t_other</span> <span class="o">&lt;</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">tol</span>

        <span class="k">return</span> <span class="n">flag_collision</span>


<span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="n">vertex0</span><span class="p">,</span> <span class="n">vertex1</span><span class="p">,</span> <span class="n">vertex2</span><span class="p">,</span> <span class="n">angle_type</span><span class="o">=</span><span class="s1">&#39;signed&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the angle between two edges  vertex0-vertex1 and  vertex0-vertex2 having an endpoint in</span>
<span class="sd">    common. The angle is computed by starting from the edge  vertex0-- vertex1, and then</span>
<span class="sd">    ``walking&#39;&#39; in a counterclockwise manner until the edge  vertex0-vertex2 is found.</span>
<span class="sd">    The angle is computed by starting from the vertex0-vertex1 edge, and then “walking” in a</span>
<span class="sd">    counterclockwise manner until the is found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># tolerance to check for coincident points</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">2.22e-16</span>

    <span class="c1"># compute vectors corresponding to the two edges, and normalize</span>
    <span class="n">vec1</span> <span class="o">=</span> <span class="n">vertex1</span> <span class="o">-</span> <span class="n">vertex0</span>
    <span class="n">vec2</span> <span class="o">=</span> <span class="n">vertex2</span> <span class="o">-</span> <span class="n">vertex0</span>

    <span class="n">norm_vec1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec1</span><span class="p">)</span>
    <span class="n">norm_vec2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">norm_vec1</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">or</span> <span class="n">norm_vec2</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
        <span class="c1"># vertex1 or vertex2 coincides with vertex0, abort</span>
        <span class="n">edge_angle</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">edge_angle</span>

    <span class="n">vec1</span> <span class="o">=</span> <span class="n">vec1</span> <span class="o">/</span> <span class="n">norm_vec1</span>
    <span class="n">vec2</span> <span class="o">=</span> <span class="n">vec2</span> <span class="o">/</span> <span class="n">norm_vec2</span>

    <span class="c1"># Transform vec1 and vec2 into flat 3-D vectors,</span>
    <span class="c1"># so that they can be used with np.inner and np.cross</span>
    <span class="n">vec1flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">vec1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">vec2flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">vec2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="n">c_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">vec1flat</span><span class="p">,</span> <span class="n">vec2flat</span><span class="p">)</span>
    <span class="n">s_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">vec1flat</span><span class="p">,</span> <span class="n">vec2flat</span><span class="p">))</span>

    <span class="n">edge_angle</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">s_angle</span><span class="p">,</span> <span class="n">c_angle</span><span class="p">)</span>

    <span class="n">angle_type</span> <span class="o">=</span> <span class="n">angle_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">angle_type</span> <span class="o">==</span> <span class="s1">&#39;signed&#39;</span><span class="p">:</span>
        <span class="c1"># nothing to do</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">angle_type</span> <span class="o">==</span> <span class="s1">&#39;unsigned&#39;</span><span class="p">:</span>
        <span class="n">edge_angle</span> <span class="o">=</span> <span class="p">(</span><span class="n">edge_angle</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid argument angle_type&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">edge_angle</span>
</pre></div>

<h1>me570_potential.py</h1>
<div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Classes to define potential and potential planner for the sphere world</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">io</span> <span class="k">as</span> <span class="n">scio</span>
<span class="kn">import</span> <span class="nn">me570_geometry</span>
<span class="kn">from</span> <span class="nn">me570_qp</span> <span class="kn">import</span> <span class="n">qp_supervisor</span>


<span class="k">class</span> <span class="nc">SphereWorld</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Class for loading and plotting a 2-D sphereworld. &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the sphere world from the provided file sphereworld.mat, and sets the</span>
<span class="sd">    following attributes:</span>
<span class="sd">     -  world: a  nb_spheres list of  Sphere objects defining all the spherical obstacles in the</span>
<span class="sd">    sphere world.</span>
<span class="sd">     -  x_start, a [2 x nb_start] array of initial starting locations (one for each column).</span>
<span class="sd">     -  x_goal, a [2 x nb_goal] vector containing the coordinates of different goal locations (one</span>
<span class="sd">    for each column).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">scio</span><span class="o">.</span><span class="n">loadmat</span><span class="p">(</span><span class="s1">&#39;sphereWorld.mat&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">world</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sphere_args</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;world&#39;</span><span class="p">],</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">)):</span>
            <span class="n">sphere_args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asscalar</span><span class="p">(</span><span class="n">sphere_args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">sphere_args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asscalar</span><span class="p">(</span><span class="n">sphere_args</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">world</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">me570_geometry</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="o">*</span><span class="n">sphere_args</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x_goal</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;xGoal&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_start</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;xStart&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta_start</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;thetaStart&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses Sphere.plot to draw the spherical obstacles together with a</span>
<span class="sd">        * marker at the goal location.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">sphere</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">world</span><span class="p">:</span>
            <span class="n">sphere</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_goal</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_goal</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="o">-</span><span class="mi">11</span><span class="p">,</span> <span class="mi">11</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">11</span><span class="p">,</span> <span class="mi">11</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">RepulsiveSphere</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Repulsive potential for a sphere &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sphere</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the arguments to internal attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sphere</span> <span class="o">=</span> <span class="n">sphere</span>

    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_eval</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the repulsive potential from  sphere at the location x= x_eval. The function returns</span>
<span class="sd">    the repulsive potential as given by</span>
<span class="sd">    (  eq:repulsive  ).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d_subi_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">x_eval</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">d_subi_x</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sphere</span><span class="o">.</span><span class="n">distance_influence</span><span class="p">:</span>
            <span class="n">u_rep</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">d_subi_x</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sphere</span><span class="o">.</span><span class="n">distance_influence</span><span class="p">:</span>
            <span class="n">u_rep</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">d_subi_x</span> <span class="o">-</span>
                           <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sphere</span><span class="o">.</span><span class="n">distance_influence</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u_rep</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">return</span> <span class="n">u_rep</span>

    <span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_eval</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the gradient of U_ rep for a single sphere, as given by</span>
<span class="sd">        (eq:repulsive-gradient).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d_subi_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">x_eval</span><span class="p">)</span>
        <span class="n">grad_d_subi_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sphere</span><span class="o">.</span><span class="n">distance_grad</span><span class="p">(</span><span class="n">x_eval</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">d_subi_x</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sphere</span><span class="o">.</span><span class="n">distance_influence</span><span class="p">:</span>
            <span class="n">grad_u_rep</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">d_subi_x</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sphere</span><span class="o">.</span><span class="n">distance_influence</span><span class="p">:</span>
            <span class="n">grad_u_rep</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">d_subi_x</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sphere</span><span class="o">.</span><span class="n">distance_influence</span>
                           <span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">d_subi_x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">grad_d_subi_x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grad_u_rep</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">return</span> <span class="n">grad_u_rep</span>


<span class="k">class</span> <span class="nc">Attractive</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Repulsive potential for a sphere &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">potential</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the arguments to internal attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">potential</span> <span class="o">=</span> <span class="n">potential</span>

    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_eval</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the attractive potential  U_ attr at a point  xEval with respect to a goal location</span>
<span class="sd">    potential.xGoal given by the formula: If  potential.shape is equal to  &#39;conic&#39;, use p=1. If</span>
<span class="sd">    potential.shape is equal to  &#39;quadratic&#39;, use p=2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Test if the necessary keys are a subset of self.potential</span>
        <span class="k">if</span> <span class="p">{</span><span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="s1">&#39;x_goal&#39;</span><span class="p">}</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">potential</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">attr_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">potential</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">attr_shape</span> <span class="o">==</span> <span class="s2">&quot;conic&quot;</span><span class="p">:</span>
                <span class="n">u_attr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x_eval</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">potential</span><span class="p">[</span><span class="s1">&#39;x_goal&#39;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">attr_shape</span> <span class="o">==</span> <span class="s2">&quot;quadratic&quot;</span><span class="p">:</span>
                <span class="n">u_attr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x_eval</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">potential</span><span class="p">[</span><span class="s1">&#39;x_goal&#39;</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Attractive Potential is undefined for shape, </span><span class="se">\&quot;</span><span class="si">{</span><span class="n">attr_shape</span><span class="si">}</span><span class="se">\&quot;</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Definition of potential does not indicate a shape&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">u_attr</span>

    <span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_eval</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the gradient of the attractive potential  U_ attr at a point  xEval. The gradient is</span>
<span class="sd">    given by the formula If  potential[&#39;shape&#39;] is equal to  &#39;conic&#39;, use p=1; if it is equal to</span>
<span class="sd">    &#39;quadratic&#39;, use p=2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Test if the necessary keys are a subset of self.potential</span>
        <span class="k">if</span> <span class="p">{</span><span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="s1">&#39;x_goal&#39;</span><span class="p">}</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">potential</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">attr_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">potential</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">attr_shape</span> <span class="o">==</span> <span class="s2">&quot;conic&quot;</span><span class="p">:</span>
                <span class="n">grad_u_attr</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_eval</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">potential</span><span class="p">[</span><span class="s1">&#39;x_goal&#39;</span><span class="p">]</span>
                               <span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x_eval</span> <span class="o">-</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">potential</span><span class="p">[</span><span class="s1">&#39;x_goal&#39;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">attr_shape</span> <span class="o">==</span> <span class="s2">&quot;quadratic&quot;</span><span class="p">:</span>
                <span class="n">grad_u_attr</span> <span class="o">=</span> <span class="n">x_eval</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">potential</span><span class="p">[</span><span class="s1">&#39;x_goal&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Attractive Potential is undefined for shape, </span><span class="se">\&quot;</span><span class="si">{</span><span class="n">attr_shape</span><span class="si">}</span><span class="se">\&quot;</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Definition of potential does not indicate a shape&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">grad_u_attr</span>


<span class="k">class</span> <span class="nc">Total</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Combines attractive and repulsive potentials &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">world</span><span class="p">,</span> <span class="n">potential</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the arguments to internal attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">world</span><span class="p">:</span> <span class="n">SphereWorld</span> <span class="o">=</span> <span class="n">world</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">potential</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">potential</span>

    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_eval</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the function U=U_attr+a*iU_rep,i, where a is given by the variable</span>
<span class="sd">    potential.repulsiveWeight</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure the proper fields are present</span>
        <span class="c1"># obstacles: list[RepulsiveSphere] = []</span>
        <span class="n">obstacle_potential</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="p">{</span><span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="s1">&#39;x_goal&#39;</span><span class="p">,</span> <span class="s1">&#39;repulsive_weight&#39;</span><span class="p">}</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">potential</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="n">Attractive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">potential</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sphere</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">world</span><span class="o">.</span><span class="n">world</span><span class="p">:</span>
                <span class="n">obstacle_potential</span> <span class="o">=</span> <span class="n">obstacle_potential</span> <span class="o">+</span> <span class="n">RepulsiveSphere</span><span class="p">(</span>
                    <span class="n">sphere</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">x_eval</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Must have all necessary fields: &#39;shape&#39;, &#39;x_goal&#39;, and &#39;repulsive_weight&#39;&quot;</span>
            <span class="p">)</span>

        <span class="n">u_eval</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span>
            <span class="n">x_eval</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">potential</span><span class="p">[</span><span class="s1">&#39;repulsive_weight&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">obstacle_potential</span>

        <span class="k">return</span> <span class="n">u_eval</span>

    <span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_eval</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the gradient of the total potential,</span>
<span class="sd">    U= U_ attr+    _i U_ rep,i, where   is given by the variable</span>
<span class="sd">    potential.repulsiveWeight</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure the proper fields are present</span>
        <span class="n">obstacle_gradient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">{</span><span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="s1">&#39;x_goal&#39;</span><span class="p">,</span> <span class="s1">&#39;repulsive_weight&#39;</span><span class="p">}</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">potential</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="n">Attractive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">potential</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sphere</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">world</span><span class="o">.</span><span class="n">world</span><span class="p">:</span>
                <span class="n">obstacle_gradient</span> <span class="o">=</span> <span class="n">obstacle_gradient</span> <span class="o">+</span> <span class="n">RepulsiveSphere</span><span class="p">(</span>
                    <span class="n">sphere</span><span class="p">)</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">x_eval</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Must have all necessary fields: &#39;shape&#39;, &#39;x_goal&#39;, and &#39;repulsive_weight&#39;&quot;</span>
            <span class="p">)</span>

        <span class="n">grad_u_eval</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span>
            <span class="n">x_eval</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">potential</span><span class="p">[</span><span class="s1">&#39;repulsive_weight&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">obstacle_gradient</span>
        <span class="k">return</span> <span class="n">grad_u_eval</span>


<span class="k">class</span> <span class="nc">Planner</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Planner for creating the path from start -&gt; goal</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_start</span><span class="p">,</span> <span class="n">planner_parameters</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function uses a given function ( planner_parameters[&#39;control&#39;]) to implement a generic</span>
<span class="sd">    potential-based planner with step size  planner_parameters[&#39;epsilon&#39;], and evaluates the cost</span>
<span class="sd">    along the returned path. The planner must stop when either the number of steps given by</span>
<span class="sd">    planner_parameters[&#39;nb_steps&#39;] is reached, or when the norm of the vector given by</span>
<span class="sd">    planner_parameters[&#39;control&#39;] is less than 5 10^-3 (equivalently,  5e-3).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Create the trajectory path of the robot, pre-filling the list with 0s</span>
        <span class="c1"># in case the planner stops early</span>
        <span class="n">x_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">planner_parameters</span><span class="p">[</span><span class="s1">&#39;nb_steps&#39;</span><span class="p">]))</span>

        <span class="c1"># The first value is always going to be where the robot starts</span>
        <span class="n">x_path</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_start</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Create the list of potential values, pre-filling the list with 0s in case</span>
        <span class="c1"># the planner stops early</span>
        <span class="n">u_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">planner_parameters</span><span class="p">[</span><span class="s1">&#39;nb_steps&#39;</span><span class="p">])</span>

        <span class="c1"># The first potential is always going to be evaluated at the start location</span>
        <span class="n">u_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">planner_parameters</span><span class="p">[</span><span class="s1">&#39;U&#39;</span><span class="p">](</span><span class="n">x_start</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">planner_parameters</span><span class="p">[</span><span class="s1">&#39;nb_steps&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">x_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">x_path</span><span class="p">[:,</span> <span class="n">k</span><span class="p">])</span>
            <span class="n">control_val</span> <span class="o">=</span> <span class="n">planner_parameters</span><span class="p">[</span><span class="s1">&#39;control&#39;</span><span class="p">](</span><span class="n">x_val</span><span class="p">)</span>

            <span class="c1"># Determines if the planner should stop since the gradient is essentially 0</span>
            <span class="c1"># (meaning either stuck or found goal)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">control_val</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">5e-3</span><span class="p">:</span>
                <span class="n">x_path</span><span class="p">[:,</span> <span class="n">k</span><span class="p">:]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">u_path</span><span class="p">[</span><span class="n">k</span><span class="p">:]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">break</span>

            <span class="n">x_path</span><span class="p">[:,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_val</span> <span class="o">+</span>
                                <span class="n">planner_parameters</span><span class="p">[</span><span class="s1">&#39;epsilon&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">control_val</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

            <span class="n">u_path</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">planner_parameters</span><span class="p">[</span><span class="s1">&#39;U&#39;</span><span class="p">](</span><span class="n">x_val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x_path</span><span class="p">,</span> <span class="n">u_path</span>

    <span class="k">def</span> <span class="nf">run_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function performs the following steps:</span>
<span class="sd">     - Loads the problem data from the file !70!DarkSeaGreen2 sphereworld.mat.</span>
<span class="sd">     - For each goal location in  world.xGoal:</span>
<span class="sd">     - Uses the function Sphereworld.plot to plot the world in a first figure.</span>
<span class="sd">     - Sets  planner_parameters[&#39;U&#39;] to the negative of  Total.grad.</span>
<span class="sd">     - it:grad-handle Calls the function Potential.planner with the problem data and the input</span>
<span class="sd">    arguments. The function needs to be called five times, using each one of the initial locations</span>
<span class="sd">    given in  x_start (also provided in !70!DarkSeaGreen2 sphereworld.mat).</span>
<span class="sd">     - it:plot-plan After each call, plot the resulting trajectory superimposed to the world in the</span>
<span class="sd">    first subplot; in a second subplot, show  u_path (using the same color and using the  semilogy</span>
<span class="sd">    command).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">world</span> <span class="o">=</span> <span class="n">SphereWorld</span><span class="p">()</span>
        <span class="c1"># self.plot_quadratics(</span>
        <span class="c1">#     {</span>
        <span class="c1">#         &#39;repulsive_weight&#39;: 35,</span>
        <span class="c1">#         &#39;epsilon&#39;: 2e-2,</span>
        <span class="c1">#         &#39;nb_steps&#39;: 600</span>
        <span class="c1">#     }, world)</span>
        <span class="c1"># self.plot_conics(</span>
        <span class="c1">#     {</span>
        <span class="c1">#         &#39;repulsive_weight&#39;: 1,</span>
        <span class="c1">#         &#39;epsilon&#39;: 3.55e-1,</span>
        <span class="c1">#         &#39;nb_steps&#39;: 1000</span>
        <span class="c1">#     }, world)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_quad_clfcbf</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s1">&#39;repulsive_weight&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
                <span class="s1">&#39;epsilon&#39;</span><span class="p">:</span> <span class="mf">6.0e-2</span><span class="p">,</span>
                <span class="s1">&#39;nb_steps&#39;</span><span class="p">:</span> <span class="mi">100</span>
            <span class="p">},</span> <span class="n">world</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">plot_conics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">world</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method used for plotting conic potential functions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;figure.figsize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">world</span><span class="o">.</span><span class="n">x_goal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;hsv&#39;</span><span class="p">,</span> <span class="n">world</span><span class="o">.</span><span class="n">x_start</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">total_potential</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">planner_parameters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">hspace</span><span class="o">=</span><span class="mf">0.305</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">loc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">world</span><span class="o">.</span><span class="n">x_goal</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>

            <span class="c1"># Setting up the constants and parameters we need</span>
            <span class="n">total_potential</span> <span class="o">=</span> <span class="n">Total</span><span class="p">(</span>
                <span class="n">world</span><span class="p">,</span> <span class="p">{</span>
                    <span class="s1">&#39;x_goal&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">loc</span><span class="p">),</span>
                    <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="s1">&#39;conic&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;repulsive_weight&#39;</span><span class="p">:</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;repulsive_weight&#39;</span><span class="p">]</span>
                <span class="p">})</span>
            <span class="n">planner_parameters</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;U&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">point</span><span class="p">:</span> <span class="n">total_potential</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">point</span><span class="p">),</span>
                <span class="s1">&#39;control&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">point</span><span class="p">:</span> <span class="o">-</span><span class="n">total_potential</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">point</span><span class="p">),</span>
                <span class="s1">&#39;epsilon&#39;</span><span class="p">:</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;epsilon&#39;</span><span class="p">],</span>
                <span class="s1">&#39;nb_steps&#39;</span><span class="p">:</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;nb_steps&#39;</span><span class="p">]</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="n">color_num</span><span class="p">,</span> <span class="n">start_loc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">world</span><span class="o">.</span><span class="n">x_start</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
                <span class="n">curr_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">start_loc</span><span class="p">)</span>
                <span class="n">x_path</span><span class="p">,</span> <span class="n">u_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">curr_start</span><span class="p">,</span> <span class="n">planner_parameters</span><span class="p">)</span>
                <span class="c1"># Make sure we are plotting below the world we are concerned with</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">sca</span><span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_path</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">x_path</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">(</span><span class="n">color_num</span><span class="p">))</span>

                <span class="c1"># Plotting the potential on the right-hand subplot</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">sca</span><span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Goal </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, Potential Conic&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;# steps&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">planner_parameters</span><span class="p">[</span><span class="s1">&#39;nb_steps&#39;</span><span class="p">]),</span>
                             <span class="n">u_path</span><span class="p">,</span>
                             <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">(</span><span class="n">color_num</span><span class="p">))</span>

            <span class="c1"># Set current axis to left column to draw the world</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">sca</span><span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Goal </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, Trajectories Conic&quot;</span><span class="p">)</span>
            <span class="n">world</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">plot_quadratics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">world</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method for plotting quadratic potential functions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;figure.figsize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">world</span><span class="o">.</span><span class="n">x_goal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;hsv&#39;</span><span class="p">,</span> <span class="n">world</span><span class="o">.</span><span class="n">x_start</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">hspace</span><span class="o">=</span><span class="mf">0.305</span><span class="p">)</span>

        <span class="n">total_potential</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">planner_parameters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">loc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">world</span><span class="o">.</span><span class="n">x_goal</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>

            <span class="c1"># Setting up the constants and parameters we need</span>
            <span class="n">total_potential</span> <span class="o">=</span> <span class="n">Total</span><span class="p">(</span>
                <span class="n">world</span><span class="p">,</span> <span class="p">{</span>
                    <span class="s1">&#39;x_goal&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">loc</span><span class="p">),</span>
                    <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;repulsive_weight&#39;</span><span class="p">:</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;repulsive_weight&#39;</span><span class="p">]</span>
                <span class="p">})</span>
            <span class="n">planner_parameters</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;U&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">point</span><span class="p">:</span> <span class="n">total_potential</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">point</span><span class="p">),</span>
                <span class="s1">&#39;control&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">point</span><span class="p">:</span> <span class="o">-</span><span class="n">total_potential</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">point</span><span class="p">),</span>
                <span class="s1">&#39;epsilon&#39;</span><span class="p">:</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;epsilon&#39;</span><span class="p">],</span>
                <span class="s1">&#39;nb_steps&#39;</span><span class="p">:</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;nb_steps&#39;</span><span class="p">]</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="n">color_num</span><span class="p">,</span> <span class="n">start_loc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">world</span><span class="o">.</span><span class="n">x_start</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
                <span class="n">curr_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">start_loc</span><span class="p">)</span>
                <span class="n">x_path</span><span class="p">,</span> <span class="n">u_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">curr_start</span><span class="p">,</span> <span class="n">planner_parameters</span><span class="p">)</span>
                <span class="c1"># Make sure we are plotting below the world we are concerned with</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">sca</span><span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_path</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">x_path</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">(</span><span class="n">color_num</span><span class="p">))</span>

                <span class="c1"># Plotting the potential on the right-hand subplot</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">sca</span><span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Goal </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, Potential Quadratic&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;# steps&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">planner_parameters</span><span class="p">[</span><span class="s1">&#39;nb_steps&#39;</span><span class="p">]),</span>
                             <span class="n">u_path</span><span class="p">,</span>
                             <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">(</span><span class="n">color_num</span><span class="p">))</span>

            <span class="c1"># Set current axis to left column to draw the world</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">sca</span><span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Goal </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, Trajectories Quadratic&quot;</span><span class="p">)</span>
            <span class="n">world</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">plot_quad_clfcbf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">world</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method for plotting quadratic potential functions using CLF-CBF Formulation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;figure.figsize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">world</span><span class="o">.</span><span class="n">x_goal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;hsv&#39;</span><span class="p">,</span> <span class="n">world</span><span class="o">.</span><span class="n">x_start</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">hspace</span><span class="o">=</span><span class="mf">0.305</span><span class="p">)</span>

        <span class="c1"># Get rid of pylint errors of defining a variable in a loop</span>
        <span class="n">potential</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">planner_parameters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">loc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">world</span><span class="o">.</span><span class="n">x_goal</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>

            <span class="c1"># Setting up the constants and parameters we need</span>
            <span class="n">potential</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;x_goal&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">loc</span><span class="p">),</span>
                <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">,</span>
                <span class="s1">&#39;repulsive_weight&#39;</span><span class="p">:</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;repulsive_weight&#39;</span><span class="p">]</span>
            <span class="p">}</span>
            <span class="n">planner_parameters</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;U&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">point</span><span class="p">:</span> <span class="n">Total</span><span class="p">(</span><span class="n">world</span><span class="p">,</span> <span class="n">potential</span><span class="p">)</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">point</span><span class="p">),</span>
                <span class="s1">&#39;control&#39;</span><span class="p">:</span>
                <span class="k">lambda</span> <span class="n">point</span><span class="p">:</span> <span class="n">clfcbf_control</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">world</span><span class="p">,</span> <span class="n">potential</span><span class="p">),</span>
                <span class="s1">&#39;epsilon&#39;</span><span class="p">:</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;epsilon&#39;</span><span class="p">],</span>
                <span class="s1">&#39;nb_steps&#39;</span><span class="p">:</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;nb_steps&#39;</span><span class="p">]</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="n">color_num</span><span class="p">,</span> <span class="n">start_loc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">world</span><span class="o">.</span><span class="n">x_start</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
                <span class="n">curr_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">start_loc</span><span class="p">)</span>
                <span class="n">x_path</span><span class="p">,</span> <span class="n">u_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">curr_start</span><span class="p">,</span> <span class="n">planner_parameters</span><span class="p">)</span>
                <span class="c1"># Make sure we are plotting below the world we are concerned with</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">sca</span><span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_path</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">x_path</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">(</span><span class="n">color_num</span><span class="p">))</span>

                <span class="c1"># Plotting the potential on the right-hand subplot</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">sca</span><span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Goal </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, Potential Quadratic&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;# steps&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">planner_parameters</span><span class="p">[</span><span class="s1">&#39;nb_steps&#39;</span><span class="p">]),</span>
                             <span class="n">u_path</span><span class="p">,</span>
                             <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">(</span><span class="n">color_num</span><span class="p">))</span>

            <span class="c1"># Set current axis to left column to draw the world</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">sca</span><span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Goal </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, Trajectories Quadratic&quot;</span><span class="p">)</span>
            <span class="n">world</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">clfcbf_control</span><span class="p">(</span><span class="n">x_eval</span><span class="p">,</span> <span class="n">world</span><span class="p">,</span> <span class="n">potential</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute u^* according to</span>
<span class="sd">    (  eq:clfcbf-qp  ).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nb_obstacles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">world</span><span class="o">.</span><span class="n">world</span><span class="p">)</span>
    <span class="n">a_barrier</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nb_obstacles</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">b_barrier</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nb_obstacles</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">u_ref</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">Attractive</span><span class="p">(</span><span class="n">potential</span><span class="p">)</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">x_eval</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">obst_num</span><span class="p">,</span> <span class="n">sphere</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">world</span><span class="o">.</span><span class="n">world</span><span class="p">):</span>
        <span class="n">a_barrier</span><span class="p">[</span><span class="n">obst_num</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">sphere</span><span class="o">.</span><span class="n">distance_grad</span><span class="p">(</span><span class="n">x_eval</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">b_barrier</span><span class="p">[</span><span class="n">obst_num</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">potential</span><span class="p">[</span><span class="s1">&#39;repulsive_weight&#39;</span><span class="p">]</span> <span class="o">*</span>
                                   <span class="n">sphere</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">x_eval</span><span class="p">))</span>

    <span class="n">u_opt</span> <span class="o">=</span> <span class="n">qp_supervisor</span><span class="p">(</span><span class="n">a_barrier</span><span class="p">,</span> <span class="n">b_barrier</span><span class="p">,</span> <span class="n">u_ref</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">u_opt</span>
</pre></div>

<h1>me570_robot.py</h1>
<div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Please merge the functions and classes from this file with the same file from the previous</span>
<span class="sd">homework assignment</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">me570_geometry</span> <span class="k">as</span> <span class="nn">gm</span>
<span class="kn">import</span> <span class="nn">me570_potential</span> <span class="k">as</span> <span class="nn">pot</span>


<span class="k">class</span> <span class="nc">TwoLink</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for creating our Two_Link Manipulator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates the two polygons necessary for the robot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">add_y_reflection</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">vertices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
            <span class="p">[</span><span class="n">vertices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vertices</span><span class="p">))])</span>

        <span class="n">vertices1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.11</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.511</span><span class="p">]])</span>
        <span class="n">vertices1</span> <span class="o">=</span> <span class="n">add_y_reflection</span><span class="p">(</span><span class="n">vertices1</span><span class="p">)</span>
        <span class="n">vertices2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">3.97</span><span class="p">,</span> <span class="mf">4.17</span><span class="p">,</span> <span class="mf">5.38</span><span class="p">,</span> <span class="mf">5.61</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">],</span>
                              <span class="p">[</span><span class="o">-</span><span class="mf">0.47</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.75</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.97</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.313</span><span class="p">]])</span>
        <span class="n">vertices2</span> <span class="o">=</span> <span class="n">add_y_reflection</span><span class="p">(</span><span class="n">vertices2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span> <span class="o">=</span> <span class="p">(</span><span class="n">gm</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">vertices1</span><span class="p">),</span> <span class="n">gm</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">vertices2</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns two polygons that represent the links in a simple 2-D two-link manipulator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span>

    <span class="k">def</span> <span class="nf">kinematic_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The function returns the coordinate of the end effector, plus the vertices of the links, all</span>
<span class="sd">    transformed according to  _1, _2.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Rotation matrices</span>
        <span class="n">w_r_beta_1</span> <span class="o">=</span> <span class="n">gm</span><span class="o">.</span><span class="n">rot2d</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">beta_1_r_beta_2</span> <span class="o">=</span> <span class="n">gm</span><span class="o">.</span><span class="n">rot2d</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">w_r_beta_2</span> <span class="o">=</span> <span class="n">w_r_beta_1</span> <span class="o">@</span> <span class="n">beta_1_r_beta_2</span>

        <span class="c1"># Translation matrix</span>
        <span class="n">beta_1_t_beta_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">w_t_beta_2</span> <span class="o">=</span> <span class="n">gm</span><span class="o">.</span><span class="n">rot2d</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">@</span> <span class="n">beta_1_t_beta_2</span>

        <span class="c1"># Transform End effector from β₂ to the world</span>
        <span class="n">vertex_effector_transf</span> <span class="o">=</span> <span class="p">(</span><span class="n">w_r_beta_2</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span> <span class="o">+</span> <span class="n">w_t_beta_2</span>

        <span class="c1"># Polygon1&#39;s coordinates are in the β₁ coordinate space, so we need to calculate ʷp_β₁</span>
        <span class="n">polygon_1_vert_transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[],</span> <span class="p">[]])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">nb_vertices</span><span class="p">):</span>
            <span class="n">vertex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">vertex_transf</span> <span class="o">=</span> <span class="p">(</span><span class="n">w_r_beta_1</span> <span class="o">@</span> <span class="n">vertex</span><span class="p">)</span>
            <span class="n">polygon_1_vert_transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                <span class="p">(</span><span class="n">polygon_1_vert_transf</span><span class="p">,</span> <span class="n">vertex_transf</span><span class="p">))</span>

        <span class="n">polygon1_transf</span> <span class="o">=</span> <span class="n">gm</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">polygon_1_vert_transf</span><span class="p">)</span>

        <span class="c1"># Polygon2&#39;s coordinates are in the β₂ coordinate space, so we need to calculate ʷp_β₂</span>
        <span class="n">polygon_2_vert_transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[],</span> <span class="p">[]])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">nb_vertices</span><span class="p">):</span>
            <span class="n">vertex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_polygons</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">vertex_transf</span> <span class="o">=</span> <span class="p">(</span><span class="n">w_r_beta_2</span> <span class="o">@</span> <span class="n">vertex</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_t_beta_2</span>
            <span class="n">polygon_2_vert_transf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                <span class="p">(</span><span class="n">polygon_2_vert_transf</span><span class="p">,</span> <span class="n">vertex_transf</span><span class="p">))</span>

        <span class="n">polygon2_transf</span> <span class="o">=</span> <span class="n">gm</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">polygon_2_vert_transf</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">vertex_effector_transf</span><span class="p">,</span> <span class="n">polygon1_transf</span><span class="p">,</span> <span class="n">polygon2_transf</span>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function should use TwoLink.kinematic_map from the previous question together with</span>
<span class="sd">        the method Polygon.plot from Homework 1 to plot the manipulator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">[</span><span class="n">_</span><span class="p">,</span> <span class="n">polygon1_transf</span><span class="p">,</span> <span class="n">polygon2_transf</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinematic_map</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">polygon1_transf</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
        <span class="n">polygon2_transf</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_collision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each specified configuration, returns  True if  any of the links of the manipulator</span>
<span class="sd">        collides with  any of the points, and  False otherwise. Use the function</span>
<span class="sd">        Polygon.is_collision to check if each link of the manipulator is in collision.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">flag_theta</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">config</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">theta</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
            <span class="p">[</span><span class="n">_</span><span class="p">,</span> <span class="n">polygon1_transf</span><span class="p">,</span> <span class="n">polygon2_transf</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinematic_map</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>

            <span class="n">flag_points</span> <span class="o">=</span> <span class="n">polygon1_transf</span><span class="o">.</span><span class="n">is_collision</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="c1"># Must logically reverse the array because Polygon.is_collision is</span>
            <span class="c1"># returning the incorrect (opposite) answer</span>
            <span class="k">if</span> <span class="kc">True</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag_points</span><span class="p">):</span>
                <span class="n">flag_theta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="n">flag_points</span> <span class="o">=</span> <span class="n">polygon2_transf</span><span class="o">.</span><span class="n">is_collision</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="c1"># Must logically reverse the array because Polygon.is_collision is</span>
            <span class="c1"># returning the incorrect (opposite) answer</span>
            <span class="k">if</span> <span class="kc">True</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">flag_points</span><span class="p">):</span>
                <span class="n">flag_theta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">flag_theta</span>

    <span class="k">def</span> <span class="nf">plot_collision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function should:</span>
<span class="sd">     - Use TwoLink.is_collision for determining if each configuration is a collision or not.</span>
<span class="sd">     - Use TwoLink.plot to plot the manipulator for all configurations, using a red color when the</span>
<span class="sd">    manipulator is in collision, and green otherwise.</span>
<span class="sd">     - Plot the points specified by  points as black asterisks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">collisions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_collision</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">is_collision</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">collisions</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_collision</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;g&#39;</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">theta</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]),</span> <span class="n">color</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">theta_dot</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implement the map for the Jacobian of the position of the end effector with respect to the</span>
<span class="sd">        joint angles as derived in Question~ q:jacobian-effector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vertex_effector_dot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">curr_theta</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">curr_theta_dot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">theta_dot</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>

            <span class="n">sin_theta_1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">curr_theta</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">cos_theta_1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">curr_theta</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="n">sin_theta_2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">curr_theta</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">cos_theta_2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">curr_theta</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">derivative_at_point</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[[(</span><span class="o">-</span><span class="n">sin_theta_1</span> <span class="o">*</span> <span class="n">cos_theta_2</span> <span class="o">-</span> <span class="n">cos_theta_1</span> <span class="o">*</span> <span class="n">sin_theta_2</span><span class="p">)</span> <span class="o">-</span>
                  <span class="n">sin_theta_1</span><span class="p">,</span>
                  <span class="p">(</span><span class="o">-</span><span class="n">cos_theta_1</span> <span class="o">*</span> <span class="n">sin_theta_2</span> <span class="o">-</span> <span class="n">sin_theta_1</span> <span class="o">*</span> <span class="n">cos_theta_2</span><span class="p">)</span> <span class="o">+</span>
                  <span class="n">cos_theta_1</span><span class="p">],</span>
                 <span class="p">[(</span><span class="n">cos_theta_1</span> <span class="o">*</span> <span class="n">cos_theta_2</span> <span class="o">-</span> <span class="n">sin_theta_1</span> <span class="o">*</span> <span class="n">sin_theta_2</span><span class="p">)</span> <span class="o">+</span>
                  <span class="n">cos_theta_1</span><span class="p">,</span>
                  <span class="p">(</span><span class="o">-</span><span class="n">sin_theta_1</span> <span class="o">*</span> <span class="n">sin_theta_2</span> <span class="o">+</span> <span class="n">cos_theta_1</span> <span class="o">*</span> <span class="n">cos_theta_2</span><span class="p">)</span> <span class="o">+</span>
                  <span class="n">sin_theta_1</span><span class="p">]]))</span> <span class="o">@</span> <span class="n">curr_theta_dot</span>

            <span class="n">vertex_effector_dot</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">derivative_at_point</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="k">return</span> <span class="n">vertex_effector_dot</span>

    <span class="k">def</span> <span class="nf">jacobian_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the matrix representation of the Jacobian of the position of the end effector with</span>
<span class="sd">    respect to the joint angles as derived in Question~ q:jacobian-matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sin_1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">cos_1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="n">sin_2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">cos_2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="n">jtheta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">jtheta</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">sin_1</span> <span class="o">*</span> <span class="n">cos_2</span> <span class="o">-</span> <span class="n">cos_1</span> <span class="o">*</span> <span class="n">sin_2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="n">sin_1</span><span class="p">)</span>
        <span class="n">jtheta</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">cos_1</span> <span class="o">*</span> <span class="n">sin_2</span> <span class="o">-</span> <span class="n">sin_1</span> <span class="o">*</span> <span class="n">cos_2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="n">cos_1</span><span class="p">)</span>
        <span class="n">jtheta</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="n">cos_1</span> <span class="o">*</span> <span class="n">cos_2</span> <span class="o">-</span> <span class="n">sin_1</span> <span class="o">*</span> <span class="n">sin_2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="n">cos_1</span><span class="p">)</span>
        <span class="n">jtheta</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">sin_1</span> <span class="o">*</span> <span class="n">sin_2</span> <span class="o">+</span> <span class="n">cos_1</span> <span class="o">*</span> <span class="n">cos_2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="n">sin_1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">jtheta</span>


<span class="k">class</span> <span class="nc">TwoLinkPotential</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; Combines attractive and repulsive potentials &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">world</span><span class="p">,</span> <span class="n">potential</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the arguments to internal attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">world</span> <span class="o">=</span> <span class="n">world</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">potential</span> <span class="o">=</span> <span class="n">potential</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">robot</span> <span class="o">=</span> <span class="n">TwoLink</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_pot</span> <span class="o">=</span> <span class="n">pot</span><span class="o">.</span><span class="n">Total</span><span class="p">(</span><span class="n">world</span><span class="p">,</span> <span class="n">potential</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta_eval</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the potential U pulled back through the kinematic map of the two-link manipulator, i.e.,</span>
<span class="sd">    U(  Wp_ eff(  )), where U is defined as in Question~ q:total-potential, and   Wp_ eff( ) is the</span>
<span class="sd">    position of the end effector in the world frame as a function of the joint angles   = _1\\ _2.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Transform the coordinates of the end effector into the world</span>
        <span class="n">transf_end_effector</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">robot</span><span class="o">.</span><span class="n">kinematic_map</span><span class="p">(</span><span class="n">theta_eval</span><span class="p">)</span>

        <span class="c1"># evaluate the potential at the coordinate in the world</span>
        <span class="n">u_eval_theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_pot</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">transf_end_effector</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">u_eval_theta</span>

    <span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta_eval</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the gradient of the potential U pulled back through the kinematic map of the two-link</span>
<span class="sd">    manipulator, i.e.,  _   U(  Wp_ eff(  )).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Transform the coordinates of the end effector into the world</span>
        <span class="n">trans_end_effector</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">robot</span><span class="o">.</span><span class="n">kinematic_map</span><span class="p">(</span><span class="n">theta_eval</span><span class="p">)</span>

        <span class="c1"># evaluate the potential gradient at the coordinate in the world</span>
        <span class="n">grad_u_eval_theta</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">total_pot</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">trans_end_effector</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">robot</span><span class="o">.</span><span class="n">jacobian_matrix</span><span class="p">(</span><span class="n">trans_end_effector</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">grad_u_eval_theta</span>

    <span class="k">def</span> <span class="nf">run_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">planner_parameters</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function performs the same steps as Planner.run_plot in Question~ q:potentialPlannerTest,</span>
<span class="sd">    except for the following:</span>
<span class="sd">     - In step  it:grad-handle:  planner_parameters[&#39;U&#39;] should be set to  @twolink_total, and</span>
<span class="sd">    planner_parameters[&#39;control&#39;] to the negative of  @twolink_totalGrad.</span>
<span class="sd">     - In step  it:grad-handle: Use the contents of the variable  thetaStart instead of  xStart to</span>
<span class="sd">    initialize the planner, and use only the second goal  x_goal[:,1].</span>
<span class="sd">     - In step  it:plot-plan: Use Twolink.plotAnimate to plot a decimated version of the results of</span>
<span class="sd">    the planner. Note that the output  xPath from Potential.planner will really contain a sequence</span>
<span class="sd">    of join angles, rather than a sequence of 2-D points. Plot only every 5th or 10th column of</span>
<span class="sd">    xPath (e.g., use  xPath(:,1:5:end)). To avoid clutter, plot a different figure for each start.</span>
<span class="sd">        &quot;&quot;&quot;</span>
</pre></div>

<h1>me570_hw3.py</h1>
<div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Defines a module to test general methods in other files</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">me570_geometry</span> <span class="k">as</span> <span class="nn">gm</span>


<span class="k">def</span> <span class="nf">sphere_testCollision</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Generates one figure with a sphere (with arbitrary parameters) and  nb_points=100 random points that</span>
<span class="sd">are colored according to the sign of their distance from the sphere (red for negative, green for</span>
<span class="sd">positive). Generates a second figure in the same way (and the same set of points) but flipping the</span>
<span class="sd">sign of the radius  r of the sphere. For each sampled point, plot also the result of the output</span>
<span class="sd">pointsSphere.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>

    <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">radius</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">influence_dist</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">sphere</span> <span class="o">=</span> <span class="n">gm</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">influence_dist</span><span class="p">)</span>

    <span class="n">test_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">radius</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">radius</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>

    <span class="n">collision_x</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">collision_y</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">non_collision_x</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">non_collision_y</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">flag_points</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">is_collision</span><span class="p">(</span><span class="n">test_points</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">test_points</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
        <span class="n">x_point</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y_point</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">flag_points</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">collision_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_point</span><span class="p">)</span>
            <span class="n">collision_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_point</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">non_collision_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_point</span><span class="p">)</span>
            <span class="n">non_collision_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_point</span><span class="p">)</span>

    <span class="n">sphere</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">collision_x</span><span class="p">,</span> <span class="n">collision_y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">non_collision_x</span><span class="p">,</span> <span class="n">non_collision_y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">collision_x</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
    <span class="n">collision_y</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
    <span class="n">non_collision_x</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
    <span class="n">non_collision_y</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
    <span class="n">flag_points</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="n">sphere</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span>

    <span class="n">flag_points</span> <span class="o">=</span> <span class="n">sphere</span><span class="o">.</span><span class="n">is_collision</span><span class="p">(</span><span class="n">test_points</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">test_points</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
        <span class="n">x_point</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y_point</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">flag_points</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">collision_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_point</span><span class="p">)</span>
            <span class="n">collision_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_point</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">non_collision_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_point</span><span class="p">)</span>
            <span class="n">non_collision_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_point</span><span class="p">)</span>

    <span class="n">sphere</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">collision_x</span><span class="p">,</span> <span class="n">collision_y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">non_collision_x</span><span class="p">,</span> <span class="n">non_collision_y</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


<span class="n">sphere_testCollision</span><span class="p">()</span>

<span class="c1"># attr_pot = pot.Attractive({&#39;shape&#39;: &#39;quadratic&#39;, &#39;x_goal&#39;: np.vstack((0, 0))})</span>

<span class="c1"># f_handle_attr = lambda point: attr_pot.eval(point)</span>
<span class="c1"># gm.field_plot_threshold(f_handle_attr)</span>

<span class="c1"># my_sphere = gm.Sphere(np.vstack((0, 0)), -6, 5)</span>
<span class="c1"># repulsive_pot = pot.RepulsiveSphere(my_sphere)</span>
<span class="c1"># plt.figure()</span>
<span class="c1"># my_sphere.plot(&#39;g&#39;)</span>
<span class="c1"># plt.show()</span>

<span class="c1"># f_handle_repulsive = lambda point: repulsive_pot.eval(point)</span>
<span class="c1"># gm.field_plot_threshold(f_handle_repulsive, 6, 200)</span>
<span class="c1"># plt.show()</span>

<span class="c1"># world = pot.SphereWorld()</span>
<span class="c1"># f_handle_total = lambda point: world_potential.eval(point)</span>

<span class="c1"># potential_1 = {</span>
<span class="c1">#     &#39;shape&#39;: &#39;quadratic&#39;,</span>
<span class="c1">#     &#39;x_goal&#39;: np.vstack(world.x_goal[:, 0]),</span>
<span class="c1">#     &#39;repulsive_weight&#39;: 0.01</span>
<span class="c1"># }</span>
<span class="c1"># world_potential = pot.Total(world, potential_1)</span>

<span class="c1"># plt.figure()</span>
<span class="c1"># gm.field_plot_threshold(f_handle_total, 10, 200)</span>
<span class="c1"># plt.show()</span>

<span class="c1"># potential_2 = {</span>
<span class="c1">#     &#39;shape&#39;: &#39;quadratic&#39;,</span>
<span class="c1">#     &#39;x_goal&#39;: np.vstack(world.x_goal[:, 1]),</span>
<span class="c1">#     &#39;repulsive_weight&#39;: 0.01</span>
<span class="c1"># }</span>

<span class="c1"># world_potential = pot.Total(world, potential_2)</span>

<span class="c1"># plt.figure()</span>
<span class="c1"># gm.field_plot_threshold(f_handle_total, 10, 200)</span>
<span class="c1"># plt.show()</span>

<span class="c1"># potential_3 = {</span>
<span class="c1">#     &#39;shape&#39;: &#39;conic&#39;,</span>
<span class="c1">#     &#39;x_goal&#39;: np.vstack(world.x_goal[:, 0]),</span>
<span class="c1">#     &#39;repulsive_weight&#39;: 0.01</span>
<span class="c1"># }</span>

<span class="c1"># world_potential = pot.Total(world, potential_3)</span>

<span class="c1"># plt.figure()</span>
<span class="c1"># gm.field_plot_threshold(f_handle_total, 10, 200)</span>
<span class="c1"># plt.show()</span>

<span class="c1"># potential_4 = {</span>
<span class="c1">#     &#39;shape&#39;: &#39;conic&#39;,</span>
<span class="c1">#     &#39;x_goal&#39;: np.vstack(world.x_goal[:, 1]),</span>
<span class="c1">#     &#39;repulsive_weight&#39;: 0.01</span>
<span class="c1"># }</span>

<span class="c1"># world_potential = pot.Total(world, potential_4)</span>

<span class="c1"># plt.figure()</span>
<span class="c1"># gm.field_plot_threshold(f_handle_total, 10, 200)</span>
<span class="c1"># plt.show()</span>

<span class="c1"># my_potential_planner = pot.Planner()</span>
<span class="c1"># my_potential_planner.run_plot()</span>

<span class="c1"># world = pot.SphereWorld()</span>
<span class="c1"># goal_loc = world.x_goal</span>
<span class="c1"># potential = {</span>
<span class="c1">#     &#39;x_goal&#39;: np.vstack(world.x_goal[:, 1]),</span>
<span class="c1">#     &#39;shape&#39;: &#39;quadratic&#39;,</span>
<span class="c1">#     &#39;repulsive_weight&#39;: 35</span>
<span class="c1"># }</span>
<span class="c1"># f_handle = lambda point: pot.clfcbf_control(point, world, potential)</span>
<span class="c1"># gm.field_plot_threshold(f_handle, 10, 20)</span>
<span class="c1"># world.plot()</span>
<span class="c1"># plt.show()</span>

<span class="c1"># total_potential = pot.Total(world, potential)</span>
<span class="c1"># total_pot_handle = lambda point: total_potential.eval(point)</span>
<span class="c1"># total_pot_grad_handle = lambda point: -total_potential.grad(point)</span>

<span class="c1"># plt.figure()</span>
<span class="c1"># gm.field_plot_threshold(total_pot_handle, 10, 200)</span>

<span class="c1"># plt.figure()</span>
<span class="c1"># gm.field_plot_threshold(total_pot_grad_handle, 10, 30)</span>

<span class="c1"># plt.show()</span>
</pre></div>

</body>
</html>